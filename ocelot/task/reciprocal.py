import copy
import numpy as np
import matplotlib.pyplot as plt
from pymatgen.core.structure import Structure
from ocelot.routines import fileop, mathop
from ocelot.routines.geometry import frac2cart
from scipy import interpolate

plt.switch_backend('agg')


class BZsampler:
    """
    -1. TODO write inputs
    0. TODO test spin polarized calculations
    1. band structure
    2. line effective mass
    3. TODO ellipsoid effective mass
    4. TODO group velocity
    5. TODO tb fitting, see 10.1002/adts.201800204
    """

    def __init__(self, jobcomment, structure, sampling_scheme):
        """
        object used to sample BZ

        :param str jobcomment: trivial notes
        :param Structure structure: periodic structure in direct space
        :param str sampling_scheme: 'path' or 'homogeneous'
        """
        self.jobcomment = jobcomment
        self.structure = structure
        self.sampling_scheme = sampling_scheme

    @staticmethod
    def vasp_path_data_ocelot(kpoints, outcar, eigenval):
        """
        parse vasp output in a classic band calculation, kpoints must be in the format generated by aflow

        :param eigenval:
        :param str kpoints: KPOINTS filename
        :param str outcar: OUTCAR filename
        :return: a dictionary with keys as

        """
        # TODO checker on files

        # parse outcar
        r_mat = np.zeros((3, 3))
        efermi = 0.0
        nelect = 0
        with open(outcar, 'r') as f_OUTCAR:
            lines = f_OUTCAR.readlines()
        for i, line in enumerate(lines):
            if line.startswith('      direct lattice vectors'):
                v1 = [float(num) for num in lines[i + 1].split()[3:]]
                v2 = [float(num) for num in lines[i + 2].split()[3:]]
                v3 = [float(num) for num in lines[i + 3].split()[3:]]
                r_mat = [v1, v2, v3]
            if line.startswith(' E-fermi'):
                efermi = float(lines[i].split()[2])
            if line.startswith('   NELECT'):
                nelect = int(round(float(lines[i].split()[2])))

        # parse kpoints
        with open(kpoints, 'r') as f_KPOINTS:
            lines = list(fileop.nonblank_lines(f_KPOINTS))

        kline_density = int(lines[1].split()[0])
        aflowstringkpath = [i.split('-') for i in lines[0].split()[2:]]
        segs_label = []
        for path in aflowstringkpath:
            if len(path) == 2:
                segs_label.append(path[0] + '-' + path[1])
            else:
                for i in range(len(path) - 1):
                    segs_label.append(path[i] + '-' + path[i + 1])

        kpath_kcoord = [0.0]  # these are xticks
        kroute = 0.0
        for i in range(0, len(lines[4:]), 2):
            words_s = lines[4:][i].split()
            words_e = lines[4:][i + 1].split()
            k_a_s = float(words_s[0])
            k_a_e = float(words_e[0])
            k_b_s = float(words_s[1])
            k_b_e = float(words_e[1])
            k_c_s = float(words_s[2])
            k_c_e = float(words_e[2])
            frac_v = np.array([k_a_e - k_a_s, k_b_e - k_b_s, k_c_e - k_c_s])
            length = np.linalg.norm(frac2cart(frac_v, r_mat))
            kroute = kroute + length
            kpath_kcoord.append(kroute)

        kpath_labels = []  # these are xtickslabel
        for i in range(len(aflowstringkpath)):
            if i == 0:
                pre_seg_end = ''
            else:
                pre_seg_end = aflowstringkpath[i - 1][-1]
            for j in range(len(aflowstringkpath[i])):
                if j != 0 and j != len(aflowstringkpath[i]) - 1:
                    kpath_labels.append(aflowstringkpath[i][j])
                elif j == 0:
                    kpath_labels.append(pre_seg_end + '|' + aflowstringkpath[i][j])
        kpath_labels.append(aflowstringkpath[-1][-1])

        kpt_cumulative = np.zeros(((len(kpath_kcoord) - 1) * kline_density))  # these are x
        for i in range(len(kpath_kcoord) - 1):
            seg = np.linspace(kpath_kcoord[i], kpath_kcoord[i + 1], num=kline_density)
            for j in range(kline_density):
                kpt_cumulative[i * kline_density + j] = seg[j]

        # parse EIGENVAL
        with open(eigenval, 'r') as f_EIGENVAL:
            lines = list(fileop.nonblank_lines(f_EIGENVAL))
        nkpts = int(lines[5].split()[1])
        nbands = int(lines[5].split()[2])
        eigens = np.empty([nbands, nkpts], dtype='float')  # these are y
        kpts_frac = []
        kpts_cart = []
        eigen_lines = lines[6:]
        for i in range(nkpts):
            block = eigen_lines[i * (nbands + 1):(i + 1) * (nbands + 1)]
            kpt_fcoord = [float(coord) for coord in block[0].split()[0:3]]
            kpt_v = frac2cart(kpt_fcoord, r_mat)
            kpts_frac.append(kpt_fcoord)
            kpts_cart.append(kpt_v)
            for j in range(nbands):
                eigens[j][i] = float(block[j + 1].split()[1])

        d = dict()
        d['rmat'] = r_mat  # reciprocal lattice
        d['efermi'] = efermi
        d['nelect'] = nelect
        d['vb_idx'] = int(nelect / 2) - 1
        d['cb_idx'] = int(nelect / 2)
        d['kline_density'] = kline_density
        d['segs_label'] = segs_label
        d['xticks'] = kpath_kcoord
        d['xtickslabel'] = kpath_labels
        d['kpts_frac'] = kpts_frac
        d['kpts_cart'] = kpts_cart
        d['x'] = kpt_cumulative
        d['y'] = eigens  # eigens[iband][ikpt]
        d['nkpts'] = nkpts
        d['nbands'] = nbands
        return d

    @staticmethod
    def path_bandsfit(data, fitdensity, nbandsud=5):
        """
        fit band structure with spline at a predefined fit density
        using `scipy.interpolate.splev`

        :param dict data: parsed path bands data
        :param int fitdensity: number of data points along one SEGMENT
        :param int nbandsud: iband >= ivb - nbandsud or iband <= icb - nbandsub will be fitted
        :return:
        """
        d = copy.deepcopy(data)
        segs_label = data['segs_label']
        x_raw = data['x']
        kline_density = int(data['kline_density'])
        eigens = data['y']
        nelect = data['nelect']
        eigenstofit = []  # proxy bands 5+5 x nkpts
        for i in range(int((nelect / 2) - nbandsud), int((nelect / 2) + nbandsud)):
            eigenstofit.append(eigens[i])
        d['vb_idx'] = int(len(eigenstofit) / 2) - 1
        d['cb_idx'] = int(len(eigenstofit) / 2)

        fit_eigens = np.zeros((len(eigenstofit), fitdensity * len(segs_label)))

        all_x = []
        for iband in range(len(eigenstofit)):
            y_raw = eigenstofit[iband]
            all_x = []
            all_y = []
            for seg_index in range(len(segs_label)):
                x_r = x_raw[seg_index * kline_density: (seg_index + 1) * kline_density]
                y_r = y_raw[seg_index * kline_density: (seg_index + 1) * kline_density]
                tck = interpolate.splrep(x_r, y_r, s=0.00)
                step = abs(x_r[0] - x_r[-1]) / fitdensity
                xs = [x * step + x_r[0] for x in range(fitdensity)]
                ys = [interpolate.splev(x * step + x_r[0], tck, der=0) for x in range(fitdensity)]
                ys_flat = list(np.array(ys).transpose())
                all_x += xs
                all_y += ys_flat
            fit_eigens[iband] = all_y
        d['kline_density'] = fitdensity
        d['y'] = fit_eigens
        d['x'] = all_x
        return d

    @staticmethod
    def path_ems(band_type, fluctuation, data, step):
        """
        get ems for a certian band type

        :param str band_type: 'vb' or 'cb'
        :param float fluctuation: band extrema > band maxmium - fluctuation will be considered
        :param dict data: parsed path bands data
        :param int step: the step used to define the boundary of parabola
        :return:
        """
        kline_density = data['kline_density']
        segs_label = data['segs_label']
        x = data['x']
        if band_type == 'cb':
            y = data['y'][data['cb_idx']]
            g_ex = min(y)
            ems = []
            for i in range(len(segs_label)):
                seg_x = x[i * kline_density: (i + 1) * kline_density]
                seg_y = y[i * kline_density: (i + 1) * kline_density]
                poi = []  # point of interest
                for j in range(kline_density):
                    if (j == 0 and seg_y[j] < seg_y[j + step]) or (j == kline_density - 1 and
                                                                   seg_y[j] < seg_y[j - step]):
                        if seg_y[j] < g_ex + fluctuation:
                            poi.append(j)
                    elif 2 * step < j < kline_density - 2 * step:
                        if seg_y[j] < seg_y[j + step] and seg_y[j] < seg_y[j - step] and seg_y[j] < g_ex + fluctuation:
                            poi.append(j)
                for idx in poi:
                    rb_x = mathop.ra_to_rb(seg_x)
                    ha_y = mathop.ev_to_ha(seg_y)
                    em = mathop.fd_reci_2ndder(ha_y, rb_x, idx, step=step)
                    if em > 0.0:
                        ems.append((em, idx / (kline_density - 1), segs_label[i], band_type))
            return ems

        elif band_type == 'vb':
            y = data['y'][data['vb_idx']]
            g_ex = max(y)
            ems = []
            for i in range(len(segs_label)):
                seg_x = x[i * kline_density: (i + 1) * kline_density]
                seg_y = y[i * kline_density: (i + 1) * kline_density]
                poi = []  # point of interest
                for j in range(kline_density):
                    if (j == 0 and seg_y[j + step] < seg_y[j]) or (j == kline_density - 1 and
                                                                   seg_y[j - step] < seg_y[j]):
                        if seg_y[j] > g_ex - fluctuation:
                            poi.append(j)
                    elif 2 * step < j < kline_density - 2 * step:
                        if seg_y[j] > seg_y[j + step] and seg_y[j] > seg_y[j - step] and seg_y[j] > g_ex - fluctuation:
                            poi.append(j)
                for idx in poi:
                    rb_x = mathop.ra_to_rb(seg_x)
                    ha_y = mathop.ev_to_ha(seg_y)
                    em = mathop.fd_reci_2ndder(ha_y, rb_x, idx, step=step)
                    if em < 0.0:
                        ems.append((em, idx / (kline_density - 1), segs_label[i], band_type))
            return ems

    @staticmethod
    def bands_plt(f_d, r_d, yrange, savefigname, zerofermi=True):
        """
        plot band structure with fit data as lines and raw data as scatters

        :param dict f_d: fit bands data
        :param dict r_d: raw bands data
        :param list yrange: [ymin, ymax]
        :param str savefigname: file name with externsion
        :param bool zerofermi: whether plot eigen-efermi
        """

        f, ax = plt.subplots()
        efermi = r_d['efermi']

        if zerofermi:
            r_d['y'] = r_d['y'] - efermi
            f_d['y'] = f_d['y'] - efermi
            ylabel = r'$\mathrm{E\ -\ E_f\ (eV)}$'
        else:
            ylabel = r'$\mathrm{E\ (eV)}$'
            yrange = np.array(yrange) + efermi

        for i in range(len(f_d['y'])):
            x_fit = f_d['x']
            y_fit = f_d['y'][i]
            ax.plot(x_fit, y_fit, 'b-', linewidth=0.5, alpha=0.9)

        for i in range(len(r_d['y'])):
            ax.scatter(r_d['x'], r_d['y'][i], c='r', s=0.2)

        ax.set_xlabel(r'$\mathrm{k\ (2\pi \cdot \AA^{-1}})}$')
        ax.set_ylabel(ylabel)
        ax.set_xlim(r_d['x'][0], r_d['x'][-1])
        ax.set_ylim(yrange)
        ax.set_xticks(r_d['xticks'])
        ax.set_xticklabels(r_d['xtickslabel'])
        for i in r_d['xticks']:
            ax.axvline(x=i, color='black')
        plt.tight_layout()
        plt.savefig(savefigname, dpi=600)
